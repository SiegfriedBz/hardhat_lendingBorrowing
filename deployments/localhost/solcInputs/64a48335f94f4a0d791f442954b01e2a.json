{
  "language": "Solidity",
  "sources": {
    "contracts/LendingBorrowing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nerror Unauthorized();\nerror InterestRateOutOfRange();\nerror AmountSentCanNotBeNull();\nerror NotEnoughFundsInContract();\nerror Max2LoansAllowed();\nerror LoanMustExist();\nerror TotalLoanMustBePaid();\nerror ContractBalanceIsNull();\n\n/** @title LendingBorrowing : contract for lending&borrowing ETH\n *  @author SiegfriedBz\n *  @notice This contract allows lenders to receive interests on loans, as a function of each lender balance/contract balance at the time a loan is created\n *  @notice This contract allows borrowers to create a max of 2 active loans at a given time\n */\ncontract LendingBorrowing {\n    uint256 public immutable i_interestRate;\n    uint256 public totalActiveLoanCounter;\n    address payable public immutable i_owner;\n    address[] public lenders;\n    mapping(address => uint256) public lenderToBalance;\n    mapping(address => Loan[]) public borrowerToLoans;\n    struct Loan {\n        uint256 id;\n        uint256 debt; // with interest\n        address borrower;\n        mapping(address => uint256) lenderToDebt; // due debt with interest for each lender\n    }\n\n    modifier onlyLender() {\n        if (lenderToBalance[msg.sender] == 0) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    constructor(uint256 _interestRate) {\n        if (_interestRate == 0 || _interestRate >= 10**18) {\n            /// interestRate must be ]0,1[\n            revert InterestRateOutOfRange();\n        }\n        i_owner = payable(msg.sender);\n        i_interestRate = _interestRate;\n    }\n\n    /// fallback functions\n    receive() external payable {\n        lend();\n    }\n\n    fallback() external payable {\n        lend();\n    }\n\n    /**\n     * @notice lend ETH to the contract\n     */\n    function lend() public payable {\n        if (msg.value == 0) {\n            revert AmountSentCanNotBeNull();\n        }\n        /// add new lender if not already in lenders array\n        if (lenderToBalance[msg.sender] == 0) {\n            lenders.push(msg.sender);\n        }\n        /// update lender's balance\n        lenderToBalance[msg.sender] += msg.value;\n    }\n\n    /**\n     * @notice borrow ETH from the contract\n     * creates a new loan\n     * calculates the total debt for this loan\n     * calculates the debt for each lender for this loan\n     */\n    function borrow(uint256 _amount) external payable {\n        /// revert if not enough ETH on contract\n        if (address(this).balance < _amount) {\n            revert NotEnoughFundsInContract();\n        }\n        /// revert if borrower has already 2 loans\n        if (getBorrowerActiveLoansNumber(msg.sender) >= 2) {\n            revert Max2LoansAllowed();\n        }\n        /// calculate debt with interest for this amount\n        uint256 debtWithInterest = calculateDebtWithInterest(_amount);\n        /// create Loan\n        totalActiveLoanCounter++;\n        uint256 borrowerLoanIndex = borrowerToLoans[msg.sender].length;\n        Loan[] storage borrowerLoans = borrowerToLoans[msg.sender];\n        borrowerLoans.push();\n        /// update Loan\n        borrowerLoans[borrowerLoanIndex].id = borrowerLoanIndex;\n        borrowerLoans[borrowerLoanIndex].debt = debtWithInterest;\n        borrowerLoans[borrowerLoanIndex].borrower = msg.sender;\n        /// update each lender's data\n        for (uint256 i = 0; i < lenders.length; i++) {\n            (\n                uint256 borrowedToLender,\n                uint256 debtWithInterestToLender\n            ) = calculateLenderData(lenders[i], _amount, debtWithInterest);\n            /// update each lender's balance\n            lenderToBalance[lenders[i]] -= borrowedToLender;\n            /// update borrower's debt (with interest) to each lender\n            borrowerLoans[borrowerLoanIndex].lenderToDebt[\n                    lenders[i]\n                ] = debtWithInterestToLender;\n        }\n        /// send ETH to borrower\n        (bool success, ) = payable(msg.sender).call{value: _amount}(\"\");\n        require(success);\n    }\n\n    /**\n     * @notice repay a loan : send ETH due debt to each lender\n     */\n    function payloan(uint8 _id) external payable {\n        /// loan must exist\n        if (borrowerToLoans[msg.sender].length < _id + 1) {\n            revert LoanMustExist();\n        }\n        /// payer must be borrower\n        if (borrowerToLoans[msg.sender][_id].borrower != msg.sender) {\n            revert Unauthorized();\n        }\n        /// access loan in storage\n        Loan storage targetLoan = borrowerToLoans[msg.sender][_id];\n        /// must sent enough ETH to cover total debt\n        if (msg.value != targetLoan.debt) {\n            revert TotalLoanMustBePaid();\n        }\n        /// send due debt (with interest) to each lender\n        for (uint256 i = 0; i < lenders.length; i++) {\n            uint256 debtWithInterestToLender = targetLoan.lenderToDebt[\n                lenders[i]\n            ];\n            if (debtWithInterestToLender != 0) {\n                (bool success, ) = payable(lenders[i]).call{\n                    value: debtWithInterestToLender\n                }(\"\");\n                require(success);\n            }\n        }\n        /// delete borrower this Loan\n        totalActiveLoanCounter--;\n        delete borrowerToLoans[msg.sender][_id];\n    }\n\n    /**\n     * @notice allows a lender to withdraw all ETH from the contract\n     * sends each ETH lender's balance to each lender\n     */\n    function withdraw() external payable onlyLender {\n        if (address(this).balance == 0) {\n            revert ContractBalanceIsNull();\n        }\n        for (uint256 i = 0; i < lenders.length; i++) {\n            /// send each lender balance\n            (bool success, ) = payable(lenders[i]).call{\n                value: lenderToBalance[lenders[i]]\n            }(\"\");\n            require(success);\n            /// initialize each lender's balance\n            lenderToBalance[lenders[i]] = 0;\n        }\n        /// initialize lenders' array\n        lenders = new address[](0);\n    }\n\n    /**\n     * @notice\n     * calculates the total due debt with interest for a given borrowed amount\n     */\n    function calculateDebtWithInterest(uint256 _amount)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _interest = (_amount * i_interestRate) / 10**18;\n        return _amount + _interest;\n    }\n\n    /**\n     * @notice\n     * calculates the lender's amount borrowed for a given lender - total amount borrowed\n     * calculates the lender's due debt with interest for a given lender - total amount borrowed\n     */\n    function calculateLenderData(\n        address _lender,\n        uint256 _totalAmountBorrowed, /// total Amount Borrowed in this loan\n        uint256 _debtWithInterest /// total Amount Borrowed with interest in this loan\n    ) internal view returns (uint256, uint256) {\n        /// ratio of lender's balance to total contract balance\n        uint256 fundingRatio = (lenderToBalance[_lender] * 10**2) /\n            address(this).balance;\n        /// lender's amount borrowed\n        uint256 borrowedToLender = (_totalAmountBorrowed * fundingRatio) /\n            10**2;\n        /// lender's due debt with interest\n        uint256 debtWithInterestToLender = (_debtWithInterest * fundingRatio) /\n            10**2;\n        return (borrowedToLender, debtWithInterestToLender);\n    }\n\n    /**\n     * @notice Getters\n     * returns the number of active loans for a given borrower\n     */\n    function getBorrowerActiveLoansNumber(address _borrower)\n        public\n        view\n        returns (uint8)\n    {\n        uint8 counter;\n        for (uint8 i = 0; i < borrowerToLoans[_borrower].length; i++) {\n            if (borrowerToLoans[_borrower][i].debt != 0) {\n                counter++;\n            }\n        }\n        return counter;\n    }\n\n    /**\n     * @notice Getters for front end\n     * returns the total number of lenders\n     */\n    function getNumberOfLenders() external view returns (uint256) {\n        return lenders.length;\n    }\n\n    /**\n     * @notice Getters for front end\n     * returns the total due debt with interest for a given borrower - loan\n     */\n    function getBorrowerLoanDueDebt(address _borrower, uint256 _loanId)\n        external\n        view\n        returns (uint256)\n    {\n        return borrowerToLoans[_borrower][_loanId].debt;\n    }\n\n    /**\n     * @notice Getters for front end\n     * returns the lender's due debt with interest for a given borrower - loan - lender\n     */\n    function getBorrowerLoanDueDebtToLender(\n        address _borrower,\n        uint256 _loanId,\n        address _lender\n    ) external view returns (uint256) {\n        return borrowerToLoans[_borrower][_loanId].lenderToDebt[_lender];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}